<?php
/**
 * TimesheetFileAttachment
 *
 * PHP version 7.2
 *
 * @category Class
 * @package  ChronoSheetsClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * ChronoSheets API
 *
 * <div style='font-size: 14px!important;font-family: Open Sans,sans-serif!important;color: #3b4151!important;'><p>      ChronoSheets is a flexible timesheet solution for small to medium businesses, it is free for small teams of up to 3 and there are iOS and Android apps available.  Use the ChronoSheets API to create your own custom integrations.  Before starting, sign up for a ChronoSheets account at <a target='_BLANK' href='http://tsheets.xyz/signup'>http://tsheets.xyz/signup</a>.  </p></div><div id='cs-extra-info'></div>
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ChronoSheetsClient\ChronoSheetsClientLibModel;

use \ArrayAccess;
use \ChronoSheetsClient\ObjectSerializer;

/**
 * TimesheetFileAttachment Class Doc Comment
 *
 * @category Class
 * @description A file attachment attached to a timesheet
 * @package  ChronoSheetsClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null  
 */
class TimesheetFileAttachment implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'TimesheetFileAttachment';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'timesheetId' => 'int',
        'documentS3SignedUrl' => 'string',
        'imageLargeS3SignedUrl' => 'string',
        'imageMediumS3SignedUrl' => 'string',
        'imageSmallS3SignedUrl' => 'string',
        'timesheetStart' => '\DateTime',
        'timesheetEnd' => '\DateTime',
        'fileAttachmentId' => 'int',
        'userId' => 'int',
        'orgId' => 'int',
        'mobilePlatform' => 'string',
        'attachmentType' => 'string',
        'notes' => 'string',
        'nonImageFilePath' => 'string',
        'imageLargeFilePath' => 'string',
        'imageMediumFilePath' => 'string',
        'imageSmallFilePath' => 'string',
        'originalFileName' => 'string',
        'latitude' => 'double',
        'longitude' => 'double',
        'dateUploaded' => '\DateTime',
        'dateImageCaptured' => '\DateTime',
        'storageAllocationBytes' => 'int',
        'audioDurationSeconds' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'timesheetId' => 'int32',
        'documentS3SignedUrl' => null,
        'imageLargeS3SignedUrl' => null,
        'imageMediumS3SignedUrl' => null,
        'imageSmallS3SignedUrl' => null,
        'timesheetStart' => 'date-time',
        'timesheetEnd' => 'date-time',
        'fileAttachmentId' => 'int32',
        'userId' => 'int32',
        'orgId' => 'int32',
        'mobilePlatform' => null,
        'attachmentType' => null,
        'notes' => null,
        'nonImageFilePath' => null,
        'imageLargeFilePath' => null,
        'imageMediumFilePath' => null,
        'imageSmallFilePath' => null,
        'originalFileName' => null,
        'latitude' => 'double',
        'longitude' => 'double',
        'dateUploaded' => 'date-time',
        'dateImageCaptured' => 'date-time',
        'storageAllocationBytes' => 'int64',
        'audioDurationSeconds' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'timesheetId' => 'TimesheetId',
        'documentS3SignedUrl' => 'DocumentS3SignedUrl',
        'imageLargeS3SignedUrl' => 'ImageLargeS3SignedUrl',
        'imageMediumS3SignedUrl' => 'ImageMediumS3SignedUrl',
        'imageSmallS3SignedUrl' => 'ImageSmallS3SignedUrl',
        'timesheetStart' => 'TimesheetStart',
        'timesheetEnd' => 'TimesheetEnd',
        'fileAttachmentId' => 'FileAttachmentId',
        'userId' => 'UserId',
        'orgId' => 'OrgId',
        'mobilePlatform' => 'MobilePlatform',
        'attachmentType' => 'AttachmentType',
        'notes' => 'Notes',
        'nonImageFilePath' => 'NonImageFilePath',
        'imageLargeFilePath' => 'ImageLargeFilePath',
        'imageMediumFilePath' => 'ImageMediumFilePath',
        'imageSmallFilePath' => 'ImageSmallFilePath',
        'originalFileName' => 'OriginalFileName',
        'latitude' => 'Latitude',
        'longitude' => 'Longitude',
        'dateUploaded' => 'DateUploaded',
        'dateImageCaptured' => 'DateImageCaptured',
        'storageAllocationBytes' => 'StorageAllocationBytes',
        'audioDurationSeconds' => 'AudioDurationSeconds'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'timesheetId' => 'setTimesheetId',
        'documentS3SignedUrl' => 'setDocumentS3SignedUrl',
        'imageLargeS3SignedUrl' => 'setImageLargeS3SignedUrl',
        'imageMediumS3SignedUrl' => 'setImageMediumS3SignedUrl',
        'imageSmallS3SignedUrl' => 'setImageSmallS3SignedUrl',
        'timesheetStart' => 'setTimesheetStart',
        'timesheetEnd' => 'setTimesheetEnd',
        'fileAttachmentId' => 'setFileAttachmentId',
        'userId' => 'setUserId',
        'orgId' => 'setOrgId',
        'mobilePlatform' => 'setMobilePlatform',
        'attachmentType' => 'setAttachmentType',
        'notes' => 'setNotes',
        'nonImageFilePath' => 'setNonImageFilePath',
        'imageLargeFilePath' => 'setImageLargeFilePath',
        'imageMediumFilePath' => 'setImageMediumFilePath',
        'imageSmallFilePath' => 'setImageSmallFilePath',
        'originalFileName' => 'setOriginalFileName',
        'latitude' => 'setLatitude',
        'longitude' => 'setLongitude',
        'dateUploaded' => 'setDateUploaded',
        'dateImageCaptured' => 'setDateImageCaptured',
        'storageAllocationBytes' => 'setStorageAllocationBytes',
        'audioDurationSeconds' => 'setAudioDurationSeconds'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'timesheetId' => 'getTimesheetId',
        'documentS3SignedUrl' => 'getDocumentS3SignedUrl',
        'imageLargeS3SignedUrl' => 'getImageLargeS3SignedUrl',
        'imageMediumS3SignedUrl' => 'getImageMediumS3SignedUrl',
        'imageSmallS3SignedUrl' => 'getImageSmallS3SignedUrl',
        'timesheetStart' => 'getTimesheetStart',
        'timesheetEnd' => 'getTimesheetEnd',
        'fileAttachmentId' => 'getFileAttachmentId',
        'userId' => 'getUserId',
        'orgId' => 'getOrgId',
        'mobilePlatform' => 'getMobilePlatform',
        'attachmentType' => 'getAttachmentType',
        'notes' => 'getNotes',
        'nonImageFilePath' => 'getNonImageFilePath',
        'imageLargeFilePath' => 'getImageLargeFilePath',
        'imageMediumFilePath' => 'getImageMediumFilePath',
        'imageSmallFilePath' => 'getImageSmallFilePath',
        'originalFileName' => 'getOriginalFileName',
        'latitude' => 'getLatitude',
        'longitude' => 'getLongitude',
        'dateUploaded' => 'getDateUploaded',
        'dateImageCaptured' => 'getDateImageCaptured',
        'storageAllocationBytes' => 'getStorageAllocationBytes',
        'audioDurationSeconds' => 'getAudioDurationSeconds'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const MOBILE_PLATFORM_UNKNOWN = 'Unknown';
    const MOBILE_PLATFORM_I_OS = 'iOS';
    const MOBILE_PLATFORM_ANDROID = 'Android';
    const ATTACHMENT_TYPE_IMAGE = 'Image';
    const ATTACHMENT_TYPE_WORD_DOC = 'WordDoc';
    const ATTACHMENT_TYPE_PDF = 'Pdf';
    const ATTACHMENT_TYPE_MS_SPREAD_SHEET = 'MSSpreadSheet';
    const ATTACHMENT_TYPE_MS_POWER_POINT = 'MSPowerPoint';
    const ATTACHMENT_TYPE_RICH_TEXT_FORMAT = 'RichTextFormat';
    const ATTACHMENT_TYPE_ZIP_FILE = 'ZipFile';
    const ATTACHMENT_TYPE_OTHER = 'Other';
    const ATTACHMENT_TYPE_AUDIO = 'Audio';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMobilePlatformAllowableValues()
    {
        return [
            self::MOBILE_PLATFORM_UNKNOWN,
            self::MOBILE_PLATFORM_I_OS,
            self::MOBILE_PLATFORM_ANDROID,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAttachmentTypeAllowableValues()
    {
        return [
            self::ATTACHMENT_TYPE_IMAGE,
            self::ATTACHMENT_TYPE_WORD_DOC,
            self::ATTACHMENT_TYPE_PDF,
            self::ATTACHMENT_TYPE_MS_SPREAD_SHEET,
            self::ATTACHMENT_TYPE_MS_POWER_POINT,
            self::ATTACHMENT_TYPE_RICH_TEXT_FORMAT,
            self::ATTACHMENT_TYPE_ZIP_FILE,
            self::ATTACHMENT_TYPE_OTHER,
            self::ATTACHMENT_TYPE_AUDIO,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['timesheetId'] = $data['timesheetId'] ?? null;
        $this->container['documentS3SignedUrl'] = $data['documentS3SignedUrl'] ?? null;
        $this->container['imageLargeS3SignedUrl'] = $data['imageLargeS3SignedUrl'] ?? null;
        $this->container['imageMediumS3SignedUrl'] = $data['imageMediumS3SignedUrl'] ?? null;
        $this->container['imageSmallS3SignedUrl'] = $data['imageSmallS3SignedUrl'] ?? null;
        $this->container['timesheetStart'] = $data['timesheetStart'] ?? null;
        $this->container['timesheetEnd'] = $data['timesheetEnd'] ?? null;
        $this->container['fileAttachmentId'] = $data['fileAttachmentId'] ?? null;
        $this->container['userId'] = $data['userId'] ?? null;
        $this->container['orgId'] = $data['orgId'] ?? null;
        $this->container['mobilePlatform'] = $data['mobilePlatform'] ?? null;
        $this->container['attachmentType'] = $data['attachmentType'] ?? null;
        $this->container['notes'] = $data['notes'] ?? null;
        $this->container['nonImageFilePath'] = $data['nonImageFilePath'] ?? null;
        $this->container['imageLargeFilePath'] = $data['imageLargeFilePath'] ?? null;
        $this->container['imageMediumFilePath'] = $data['imageMediumFilePath'] ?? null;
        $this->container['imageSmallFilePath'] = $data['imageSmallFilePath'] ?? null;
        $this->container['originalFileName'] = $data['originalFileName'] ?? null;
        $this->container['latitude'] = $data['latitude'] ?? null;
        $this->container['longitude'] = $data['longitude'] ?? null;
        $this->container['dateUploaded'] = $data['dateUploaded'] ?? null;
        $this->container['dateImageCaptured'] = $data['dateImageCaptured'] ?? null;
        $this->container['storageAllocationBytes'] = $data['storageAllocationBytes'] ?? null;
        $this->container['audioDurationSeconds'] = $data['audioDurationSeconds'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getMobilePlatformAllowableValues();
        if (!is_null($this->container['mobilePlatform']) && !in_array($this->container['mobilePlatform'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'mobilePlatform', must be one of '%s'",
                $this->container['mobilePlatform'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAttachmentTypeAllowableValues();
        if (!is_null($this->container['attachmentType']) && !in_array($this->container['attachmentType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'attachmentType', must be one of '%s'",
                $this->container['attachmentType'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets timesheetId
     *
     * @return int|null
     */
    public function getTimesheetId()
    {
        return $this->container['timesheetId'];
    }

    /**
     * Sets timesheetId
     *
     * @param int|null $timesheetId The ID of the timesheet this attachment is attached to.
     *
     * @return self
     */
    public function setTimesheetId($timesheetId)
    {
        $this->container['timesheetId'] = $timesheetId;

        return $this;
    }

    /**
     * Gets documentS3SignedUrl
     *
     * @return string|null
     */
    public function getDocumentS3SignedUrl()
    {
        return $this->container['documentS3SignedUrl'];
    }

    /**
     * Sets documentS3SignedUrl
     *
     * @param string|null $documentS3SignedUrl The limited use signed URL for the document (if it's not an image).  This URL is unique and will eventually expire.  If the attachment is an image, then this won't be set.
     *
     * @return self
     */
    public function setDocumentS3SignedUrl($documentS3SignedUrl)
    {
        $this->container['documentS3SignedUrl'] = $documentS3SignedUrl;

        return $this;
    }

    /**
     * Gets imageLargeS3SignedUrl
     *
     * @return string|null
     */
    public function getImageLargeS3SignedUrl()
    {
        return $this->container['imageLargeS3SignedUrl'];
    }

    /**
     * Sets imageLargeS3SignedUrl
     *
     * @param string|null $imageLargeS3SignedUrl The limited use signed URL for the large version of the image.  This URL is unique and will eventually expire.  Only set when the attachment is actually an image.
     *
     * @return self
     */
    public function setImageLargeS3SignedUrl($imageLargeS3SignedUrl)
    {
        $this->container['imageLargeS3SignedUrl'] = $imageLargeS3SignedUrl;

        return $this;
    }

    /**
     * Gets imageMediumS3SignedUrl
     *
     * @return string|null
     */
    public function getImageMediumS3SignedUrl()
    {
        return $this->container['imageMediumS3SignedUrl'];
    }

    /**
     * Sets imageMediumS3SignedUrl
     *
     * @param string|null $imageMediumS3SignedUrl The limited use signed URL for the medium version of the image.  This URL is unique and will eventually expire.  Only set when the attachment is actually an image.
     *
     * @return self
     */
    public function setImageMediumS3SignedUrl($imageMediumS3SignedUrl)
    {
        $this->container['imageMediumS3SignedUrl'] = $imageMediumS3SignedUrl;

        return $this;
    }

    /**
     * Gets imageSmallS3SignedUrl
     *
     * @return string|null
     */
    public function getImageSmallS3SignedUrl()
    {
        return $this->container['imageSmallS3SignedUrl'];
    }

    /**
     * Sets imageSmallS3SignedUrl
     *
     * @param string|null $imageSmallS3SignedUrl The limited use signed URL for the small version of the image.  This URL is unique and will eventually expire.  Only set when the attachment is actually an image.
     *
     * @return self
     */
    public function setImageSmallS3SignedUrl($imageSmallS3SignedUrl)
    {
        $this->container['imageSmallS3SignedUrl'] = $imageSmallS3SignedUrl;

        return $this;
    }

    /**
     * Gets timesheetStart
     *
     * @return \DateTime|null
     */
    public function getTimesheetStart()
    {
        return $this->container['timesheetStart'];
    }

    /**
     * Sets timesheetStart
     *
     * @param \DateTime|null $timesheetStart The start date and time of the timesheet that this attachment is attached to
     *
     * @return self
     */
    public function setTimesheetStart($timesheetStart)
    {
        $this->container['timesheetStart'] = $timesheetStart;

        return $this;
    }

    /**
     * Gets timesheetEnd
     *
     * @return \DateTime|null
     */
    public function getTimesheetEnd()
    {
        return $this->container['timesheetEnd'];
    }

    /**
     * Sets timesheetEnd
     *
     * @param \DateTime|null $timesheetEnd The end date and time of the timesheet that this attachment is attached to
     *
     * @return self
     */
    public function setTimesheetEnd($timesheetEnd)
    {
        $this->container['timesheetEnd'] = $timesheetEnd;

        return $this;
    }

    /**
     * Gets fileAttachmentId
     *
     * @return int|null
     */
    public function getFileAttachmentId()
    {
        return $this->container['fileAttachmentId'];
    }

    /**
     * Sets fileAttachmentId
     *
     * @param int|null $fileAttachmentId The ID of the file attachment
     *
     * @return self
     */
    public function setFileAttachmentId($fileAttachmentId)
    {
        $this->container['fileAttachmentId'] = $fileAttachmentId;

        return $this;
    }

    /**
     * Gets userId
     *
     * @return int|null
     */
    public function getUserId()
    {
        return $this->container['userId'];
    }

    /**
     * Sets userId
     *
     * @param int|null $userId The ID of the user who attached the file
     *
     * @return self
     */
    public function setUserId($userId)
    {
        $this->container['userId'] = $userId;

        return $this;
    }

    /**
     * Gets orgId
     *
     * @return int|null
     */
    public function getOrgId()
    {
        return $this->container['orgId'];
    }

    /**
     * Sets orgId
     *
     * @param int|null $orgId The ID of the organisation that owns the file and employs the employee
     *
     * @return self
     */
    public function setOrgId($orgId)
    {
        $this->container['orgId'] = $orgId;

        return $this;
    }

    /**
     * Gets mobilePlatform
     *
     * @return string|null
     */
    public function getMobilePlatform()
    {
        return $this->container['mobilePlatform'];
    }

    /**
     * Sets mobilePlatform
     *
     * @param string|null $mobilePlatform The mobile platform that was used to attach the file
     *
     * @return self
     */
    public function setMobilePlatform($mobilePlatform)
    {
        $allowedValues = $this->getMobilePlatformAllowableValues();
        if (!is_null($mobilePlatform) && !in_array($mobilePlatform, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'mobilePlatform', must be one of '%s'",
                    $mobilePlatform,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['mobilePlatform'] = $mobilePlatform;

        return $this;
    }

    /**
     * Gets attachmentType
     *
     * @return string|null
     */
    public function getAttachmentType()
    {
        return $this->container['attachmentType'];
    }

    /**
     * Sets attachmentType
     *
     * @param string|null $attachmentType The type of file attachment
     *
     * @return self
     */
    public function setAttachmentType($attachmentType)
    {
        $allowedValues = $this->getAttachmentTypeAllowableValues();
        if (!is_null($attachmentType) && !in_array($attachmentType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'attachmentType', must be one of '%s'",
                    $attachmentType,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['attachmentType'] = $attachmentType;

        return $this;
    }

    /**
     * Gets notes
     *
     * @return string|null
     */
    public function getNotes()
    {
        return $this->container['notes'];
    }

    /**
     * Sets notes
     *
     * @param string|null $notes Any notes regarding the file attachment
     *
     * @return self
     */
    public function setNotes($notes)
    {
        $this->container['notes'] = $notes;

        return $this;
    }

    /**
     * Gets nonImageFilePath
     *
     * @return string|null
     */
    public function getNonImageFilePath()
    {
        return $this->container['nonImageFilePath'];
    }

    /**
     * Sets nonImageFilePath
     *
     * @param string|null $nonImageFilePath The path to the file attachment as hosted by ChronoSheets storage, if it's not an image.  If the attachment is an image then this won't be set.
     *
     * @return self
     */
    public function setNonImageFilePath($nonImageFilePath)
    {
        $this->container['nonImageFilePath'] = $nonImageFilePath;

        return $this;
    }

    /**
     * Gets imageLargeFilePath
     *
     * @return string|null
     */
    public function getImageLargeFilePath()
    {
        return $this->container['imageLargeFilePath'];
    }

    /**
     * Sets imageLargeFilePath
     *
     * @param string|null $imageLargeFilePath The path to the file attachment as hosted by ChronoSheets storage, only set if it's an image.  This is regarding the large version of the image.
     *
     * @return self
     */
    public function setImageLargeFilePath($imageLargeFilePath)
    {
        $this->container['imageLargeFilePath'] = $imageLargeFilePath;

        return $this;
    }

    /**
     * Gets imageMediumFilePath
     *
     * @return string|null
     */
    public function getImageMediumFilePath()
    {
        return $this->container['imageMediumFilePath'];
    }

    /**
     * Sets imageMediumFilePath
     *
     * @param string|null $imageMediumFilePath The path to the file attachment as hosted by ChronoSheets storage, only set if it's an image.  This is regarding the medium version of the image.
     *
     * @return self
     */
    public function setImageMediumFilePath($imageMediumFilePath)
    {
        $this->container['imageMediumFilePath'] = $imageMediumFilePath;

        return $this;
    }

    /**
     * Gets imageSmallFilePath
     *
     * @return string|null
     */
    public function getImageSmallFilePath()
    {
        return $this->container['imageSmallFilePath'];
    }

    /**
     * Sets imageSmallFilePath
     *
     * @param string|null $imageSmallFilePath The path to the file attachment as hosted by ChronoSheets storage, only set if it's an image.  This is regarding the small version of the image.
     *
     * @return self
     */
    public function setImageSmallFilePath($imageSmallFilePath)
    {
        $this->container['imageSmallFilePath'] = $imageSmallFilePath;

        return $this;
    }

    /**
     * Gets originalFileName
     *
     * @return string|null
     */
    public function getOriginalFileName()
    {
        return $this->container['originalFileName'];
    }

    /**
     * Sets originalFileName
     *
     * @param string|null $originalFileName The original file name of the attachment
     *
     * @return self
     */
    public function setOriginalFileName($originalFileName)
    {
        $this->container['originalFileName'] = $originalFileName;

        return $this;
    }

    /**
     * Gets latitude
     *
     * @return double|null
     */
    public function getLatitude()
    {
        return $this->container['latitude'];
    }

    /**
     * Sets latitude
     *
     * @param double|null $latitude Meta-data indicating the latitude of the file attachment.  If the attachment is an image, this data originates from the meta data inside the image file.
     *
     * @return self
     */
    public function setLatitude($latitude)
    {
        $this->container['latitude'] = $latitude;

        return $this;
    }

    /**
     * Gets longitude
     *
     * @return double|null
     */
    public function getLongitude()
    {
        return $this->container['longitude'];
    }

    /**
     * Sets longitude
     *
     * @param double|null $longitude Meta-data indicating the longitude of the file attachment.  If the attachment is an image, this data originates from the meta data inside the image file.
     *
     * @return self
     */
    public function setLongitude($longitude)
    {
        $this->container['longitude'] = $longitude;

        return $this;
    }

    /**
     * Gets dateUploaded
     *
     * @return \DateTime|null
     */
    public function getDateUploaded()
    {
        return $this->container['dateUploaded'];
    }

    /**
     * Sets dateUploaded
     *
     * @param \DateTime|null $dateUploaded The date and time the attachment was uploaded.  Time is in UTC.
     *
     * @return self
     */
    public function setDateUploaded($dateUploaded)
    {
        $this->container['dateUploaded'] = $dateUploaded;

        return $this;
    }

    /**
     * Gets dateImageCaptured
     *
     * @return \DateTime|null
     */
    public function getDateImageCaptured()
    {
        return $this->container['dateImageCaptured'];
    }

    /**
     * Sets dateImageCaptured
     *
     * @param \DateTime|null $dateImageCaptured The original date and time the image was captured, if it was an image.  This data originates from the meta data inside the image file.
     *
     * @return self
     */
    public function setDateImageCaptured($dateImageCaptured)
    {
        $this->container['dateImageCaptured'] = $dateImageCaptured;

        return $this;
    }

    /**
     * Gets storageAllocationBytes
     *
     * @return int|null
     */
    public function getStorageAllocationBytes()
    {
        return $this->container['storageAllocationBytes'];
    }

    /**
     * Sets storageAllocationBytes
     *
     * @param int|null $storageAllocationBytes The number of bytes allocated for storing the file attachment.
     *
     * @return self
     */
    public function setStorageAllocationBytes($storageAllocationBytes)
    {
        $this->container['storageAllocationBytes'] = $storageAllocationBytes;

        return $this;
    }

    /**
     * Gets audioDurationSeconds
     *
     * @return int|null
     */
    public function getAudioDurationSeconds()
    {
        return $this->container['audioDurationSeconds'];
    }

    /**
     * Sets audioDurationSeconds
     *
     * @param int|null $audioDurationSeconds If the attachment was an audio file, this field indicates the duration of the audio file in seconds.  This data originates from the meta data inside the audio file.
     *
     * @return self
     */
    public function setAudioDurationSeconds($audioDurationSeconds)
    {
        $this->container['audioDurationSeconds'] = $audioDurationSeconds;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


