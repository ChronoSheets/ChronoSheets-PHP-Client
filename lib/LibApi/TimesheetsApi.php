<?php
/**
 * TimesheetsApi
 * PHP version 5
 *
 * @category Class
 * @package  ChronoSheetsClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * ChronoSheets API
 *
 * <div style='font-size: 14px!important;font-family: Open Sans,sans-serif!important;color: #3b4151!important;'><p>      ChronoSheets is a flexible timesheet solution for small to medium businesses, it is free for small teams of up to 3 and there are iOS and Android apps available.  Use the ChronoSheets API to create your own custom integrations.  Before starting, sign up for a ChronoSheets account at <a target='_BLANK' href='http://tsheets.xyz/signup'>http://tsheets.xyz/signup</a>.  </p></div><div id='cs-extra-info'></div>
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ChronoSheetsClient\ChronoSheetsClientLibApi;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ChronoSheetsClient\ApiException;
use ChronoSheetsClient\Configuration;
use ChronoSheetsClient\HeaderSelector;
use ChronoSheetsClient\ObjectSerializer;

/**
 * TimesheetsApi Class Doc Comment
 *
 * @category Class
 * @package  ChronoSheetsClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TimesheetsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation timesheetsCreateSingleTimesheet
     *
     * Inserts a single timesheet record.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     * @param  \ChronoSheetsClient\ChronoSheetsClientLibModel\Timesheet $request A Timesheet Request object containing values for the new Timesheet to create (required)
     *
     * @throws \ChronoSheetsClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseInt32
     */
    public function timesheetsCreateSingleTimesheet($xChronosheetsAuth, $request)
    {
        list($response) = $this->timesheetsCreateSingleTimesheetWithHttpInfo($xChronosheetsAuth, $request);
        return $response;
    }

    /**
     * Operation timesheetsCreateSingleTimesheetWithHttpInfo
     *
     * Inserts a single timesheet record.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     * @param  \ChronoSheetsClient\ChronoSheetsClientLibModel\Timesheet $request A Timesheet Request object containing values for the new Timesheet to create (required)
     *
     * @throws \ChronoSheetsClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseInt32, HTTP status code, HTTP response headers (array of strings)
     */
    public function timesheetsCreateSingleTimesheetWithHttpInfo($xChronosheetsAuth, $request)
    {
        $request = $this->timesheetsCreateSingleTimesheetRequest($xChronosheetsAuth, $request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseInt32' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseInt32', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseInt32';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseInt32',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation timesheetsCreateSingleTimesheetAsync
     *
     * Inserts a single timesheet record.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     * @param  \ChronoSheetsClient\ChronoSheetsClientLibModel\Timesheet $request A Timesheet Request object containing values for the new Timesheet to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function timesheetsCreateSingleTimesheetAsync($xChronosheetsAuth, $request)
    {
        return $this->timesheetsCreateSingleTimesheetAsyncWithHttpInfo($xChronosheetsAuth, $request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation timesheetsCreateSingleTimesheetAsyncWithHttpInfo
     *
     * Inserts a single timesheet record.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     * @param  \ChronoSheetsClient\ChronoSheetsClientLibModel\Timesheet $request A Timesheet Request object containing values for the new Timesheet to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function timesheetsCreateSingleTimesheetAsyncWithHttpInfo($xChronosheetsAuth, $request)
    {
        $returnType = '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseInt32';
        $request = $this->timesheetsCreateSingleTimesheetRequest($xChronosheetsAuth, $request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'timesheetsCreateSingleTimesheet'
     *
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     * @param  \ChronoSheetsClient\ChronoSheetsClientLibModel\Timesheet $request A Timesheet Request object containing values for the new Timesheet to create (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function timesheetsCreateSingleTimesheetRequest($xChronosheetsAuth, $request)
    {
        // verify the required parameter 'xChronosheetsAuth' is set
        if ($xChronosheetsAuth === null || (is_array($xChronosheetsAuth) && count($xChronosheetsAuth) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xChronosheetsAuth when calling timesheetsCreateSingleTimesheet'
            );
        }
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling timesheetsCreateSingleTimesheet'
            );
        }

        $resourcePath = '/Timesheets/CreateSingleTimesheet';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xChronosheetsAuth !== null) {
            $headerParams['x-chronosheets-auth'] = ObjectSerializer::toHeaderValue($xChronosheetsAuth);
        }


        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation timesheetsDeleteTimesheet
     *
     * Delete a timesheet.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  int $timesheetId The ID of the Timesheet you want to delete (required)
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     *
     * @throws \ChronoSheetsClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseBoolean
     */
    public function timesheetsDeleteTimesheet($timesheetId, $xChronosheetsAuth)
    {
        list($response) = $this->timesheetsDeleteTimesheetWithHttpInfo($timesheetId, $xChronosheetsAuth);
        return $response;
    }

    /**
     * Operation timesheetsDeleteTimesheetWithHttpInfo
     *
     * Delete a timesheet.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  int $timesheetId The ID of the Timesheet you want to delete (required)
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     *
     * @throws \ChronoSheetsClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseBoolean, HTTP status code, HTTP response headers (array of strings)
     */
    public function timesheetsDeleteTimesheetWithHttpInfo($timesheetId, $xChronosheetsAuth)
    {
        $request = $this->timesheetsDeleteTimesheetRequest($timesheetId, $xChronosheetsAuth);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseBoolean' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseBoolean', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseBoolean';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseBoolean',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation timesheetsDeleteTimesheetAsync
     *
     * Delete a timesheet.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  int $timesheetId The ID of the Timesheet you want to delete (required)
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function timesheetsDeleteTimesheetAsync($timesheetId, $xChronosheetsAuth)
    {
        return $this->timesheetsDeleteTimesheetAsyncWithHttpInfo($timesheetId, $xChronosheetsAuth)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation timesheetsDeleteTimesheetAsyncWithHttpInfo
     *
     * Delete a timesheet.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  int $timesheetId The ID of the Timesheet you want to delete (required)
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function timesheetsDeleteTimesheetAsyncWithHttpInfo($timesheetId, $xChronosheetsAuth)
    {
        $returnType = '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseBoolean';
        $request = $this->timesheetsDeleteTimesheetRequest($timesheetId, $xChronosheetsAuth);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'timesheetsDeleteTimesheet'
     *
     * @param  int $timesheetId The ID of the Timesheet you want to delete (required)
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function timesheetsDeleteTimesheetRequest($timesheetId, $xChronosheetsAuth)
    {
        // verify the required parameter 'timesheetId' is set
        if ($timesheetId === null || (is_array($timesheetId) && count($timesheetId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timesheetId when calling timesheetsDeleteTimesheet'
            );
        }
        // verify the required parameter 'xChronosheetsAuth' is set
        if ($xChronosheetsAuth === null || (is_array($xChronosheetsAuth) && count($xChronosheetsAuth) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xChronosheetsAuth when calling timesheetsDeleteTimesheet'
            );
        }

        $resourcePath = '/Timesheets/DeleteTimesheet';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($timesheetId)) {
            $timesheetId = ObjectSerializer::serializeCollection($timesheetId, '', true);
        }
        if ($timesheetId !== null) {
            $queryParams['TimesheetId'] = $timesheetId;
        }

        // header params
        if ($xChronosheetsAuth !== null) {
            $headerParams['x-chronosheets-auth'] = ObjectSerializer::toHeaderValue($xChronosheetsAuth);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation timesheetsGetTimesheets
     *
     * Get timesheets between start and end dates.  Note: the date range cannot exceed 24 hours.  This method is generally used to get timesheets for a particular day.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  \DateTime $startDate The start date of the date range (required)
     * @param  \DateTime $endDate The end date of the date range (required)
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     *
     * @throws \ChronoSheetsClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListTimesheet
     */
    public function timesheetsGetTimesheets($startDate, $endDate, $xChronosheetsAuth)
    {
        list($response) = $this->timesheetsGetTimesheetsWithHttpInfo($startDate, $endDate, $xChronosheetsAuth);
        return $response;
    }

    /**
     * Operation timesheetsGetTimesheetsWithHttpInfo
     *
     * Get timesheets between start and end dates.  Note: the date range cannot exceed 24 hours.  This method is generally used to get timesheets for a particular day.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  \DateTime $startDate The start date of the date range (required)
     * @param  \DateTime $endDate The end date of the date range (required)
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     *
     * @throws \ChronoSheetsClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListTimesheet, HTTP status code, HTTP response headers (array of strings)
     */
    public function timesheetsGetTimesheetsWithHttpInfo($startDate, $endDate, $xChronosheetsAuth)
    {
        $request = $this->timesheetsGetTimesheetsRequest($startDate, $endDate, $xChronosheetsAuth);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListTimesheet' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListTimesheet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListTimesheet';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListTimesheet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation timesheetsGetTimesheetsAsync
     *
     * Get timesheets between start and end dates.  Note: the date range cannot exceed 24 hours.  This method is generally used to get timesheets for a particular day.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  \DateTime $startDate The start date of the date range (required)
     * @param  \DateTime $endDate The end date of the date range (required)
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function timesheetsGetTimesheetsAsync($startDate, $endDate, $xChronosheetsAuth)
    {
        return $this->timesheetsGetTimesheetsAsyncWithHttpInfo($startDate, $endDate, $xChronosheetsAuth)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation timesheetsGetTimesheetsAsyncWithHttpInfo
     *
     * Get timesheets between start and end dates.  Note: the date range cannot exceed 24 hours.  This method is generally used to get timesheets for a particular day.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  \DateTime $startDate The start date of the date range (required)
     * @param  \DateTime $endDate The end date of the date range (required)
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function timesheetsGetTimesheetsAsyncWithHttpInfo($startDate, $endDate, $xChronosheetsAuth)
    {
        $returnType = '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListTimesheet';
        $request = $this->timesheetsGetTimesheetsRequest($startDate, $endDate, $xChronosheetsAuth);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'timesheetsGetTimesheets'
     *
     * @param  \DateTime $startDate The start date of the date range (required)
     * @param  \DateTime $endDate The end date of the date range (required)
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function timesheetsGetTimesheetsRequest($startDate, $endDate, $xChronosheetsAuth)
    {
        // verify the required parameter 'startDate' is set
        if ($startDate === null || (is_array($startDate) && count($startDate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startDate when calling timesheetsGetTimesheets'
            );
        }
        // verify the required parameter 'endDate' is set
        if ($endDate === null || (is_array($endDate) && count($endDate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endDate when calling timesheetsGetTimesheets'
            );
        }
        // verify the required parameter 'xChronosheetsAuth' is set
        if ($xChronosheetsAuth === null || (is_array($xChronosheetsAuth) && count($xChronosheetsAuth) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xChronosheetsAuth when calling timesheetsGetTimesheets'
            );
        }

        $resourcePath = '/Timesheets/GetTimesheets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($startDate)) {
            $startDate = ObjectSerializer::serializeCollection($startDate, '', true);
        }
        if ($startDate !== null) {
            $queryParams['StartDate'] = $startDate;
        }
        // query params
        if (is_array($endDate)) {
            $endDate = ObjectSerializer::serializeCollection($endDate, '', true);
        }
        if ($endDate !== null) {
            $queryParams['EndDate'] = $endDate;
        }

        // header params
        if ($xChronosheetsAuth !== null) {
            $headerParams['x-chronosheets-auth'] = ObjectSerializer::toHeaderValue($xChronosheetsAuth);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation timesheetsUpdateTimesheets
     *
     * Batch update timesheets.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     * @param  \ChronoSheetsClient\ChronoSheetsClientLibModel\BatchUpdateTimesheetRequest $request A BatchUpdateTimesheet Request object containing values for the new Timesheets to create or update.  If the timesheet Id is specified, then an update will be performed, else the timesheet record will be created. (required)
     *
     * @throws \ChronoSheetsClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListInt32
     */
    public function timesheetsUpdateTimesheets($xChronosheetsAuth, $request)
    {
        list($response) = $this->timesheetsUpdateTimesheetsWithHttpInfo($xChronosheetsAuth, $request);
        return $response;
    }

    /**
     * Operation timesheetsUpdateTimesheetsWithHttpInfo
     *
     * Batch update timesheets.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     * @param  \ChronoSheetsClient\ChronoSheetsClientLibModel\BatchUpdateTimesheetRequest $request A BatchUpdateTimesheet Request object containing values for the new Timesheets to create or update.  If the timesheet Id is specified, then an update will be performed, else the timesheet record will be created. (required)
     *
     * @throws \ChronoSheetsClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListInt32, HTTP status code, HTTP response headers (array of strings)
     */
    public function timesheetsUpdateTimesheetsWithHttpInfo($xChronosheetsAuth, $request)
    {
        $request = $this->timesheetsUpdateTimesheetsRequest($xChronosheetsAuth, $request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListInt32' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListInt32', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListInt32';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListInt32',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation timesheetsUpdateTimesheetsAsync
     *
     * Batch update timesheets.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     * @param  \ChronoSheetsClient\ChronoSheetsClientLibModel\BatchUpdateTimesheetRequest $request A BatchUpdateTimesheet Request object containing values for the new Timesheets to create or update.  If the timesheet Id is specified, then an update will be performed, else the timesheet record will be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function timesheetsUpdateTimesheetsAsync($xChronosheetsAuth, $request)
    {
        return $this->timesheetsUpdateTimesheetsAsyncWithHttpInfo($xChronosheetsAuth, $request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation timesheetsUpdateTimesheetsAsyncWithHttpInfo
     *
     * Batch update timesheets.    Requires the 'SubmitTimesheets' permission.
     *
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     * @param  \ChronoSheetsClient\ChronoSheetsClientLibModel\BatchUpdateTimesheetRequest $request A BatchUpdateTimesheet Request object containing values for the new Timesheets to create or update.  If the timesheet Id is specified, then an update will be performed, else the timesheet record will be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function timesheetsUpdateTimesheetsAsyncWithHttpInfo($xChronosheetsAuth, $request)
    {
        $returnType = '\ChronoSheetsClient\ChronoSheetsClientLibModel\ApiResponseListInt32';
        $request = $this->timesheetsUpdateTimesheetsRequest($xChronosheetsAuth, $request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'timesheetsUpdateTimesheets'
     *
     * @param  string $xChronosheetsAuth The ChronoSheets Auth Token (required)
     * @param  \ChronoSheetsClient\ChronoSheetsClientLibModel\BatchUpdateTimesheetRequest $request A BatchUpdateTimesheet Request object containing values for the new Timesheets to create or update.  If the timesheet Id is specified, then an update will be performed, else the timesheet record will be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function timesheetsUpdateTimesheetsRequest($xChronosheetsAuth, $request)
    {
        // verify the required parameter 'xChronosheetsAuth' is set
        if ($xChronosheetsAuth === null || (is_array($xChronosheetsAuth) && count($xChronosheetsAuth) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $xChronosheetsAuth when calling timesheetsUpdateTimesheets'
            );
        }
        // verify the required parameter 'request' is set
        if ($request === null || (is_array($request) && count($request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request when calling timesheetsUpdateTimesheets'
            );
        }

        $resourcePath = '/Timesheets/UpdateTimesheets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($xChronosheetsAuth !== null) {
            $headerParams['x-chronosheets-auth'] = ObjectSerializer::toHeaderValue($xChronosheetsAuth);
        }


        // body params
        $_tempBody = null;
        if (isset($request)) {
            $_tempBody = $request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'multipart/form-data'],
                ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
